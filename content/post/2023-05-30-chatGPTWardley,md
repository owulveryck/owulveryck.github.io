---
title: "ChatGPT, Wardley and Go"
date: 2023-05-30T21:23:17+02:00
lastmod: 2023-05-30T21:23:17+02:00
draft: false
keywords: []
description: "This article describes how I use the wardleyToGo SDK to create a plugin in Go for ChatGPT (to display Wardley Maps)"
tags: []
categories: []
author: "Olivier Wulveryck"

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: true
toc: true
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
---

In this article, I explain:
- how to create a ChatGPT plugin with Go
- how to validate the configuration with [CUE](cuelang.org)
- how to create a basic API usable with ChatGPT
- how to display SVG images within chatGPT (more a do and don't)

## Introduction

I use ChatGPT on a daily basis as an assistant, not as a dictionary or an encyclopedia. 
I seek solutions to problems and am aware that I will find them myself. 
The role of ChatGPT is to assist me and help the solutions emerge from my mind. 
I ask questions, and with its knowledge, it shapes the way I think to converge towards the solutions.

For most strategic problems, I use the tools and techniques from Wardley Mapping, including:

- The value chain (with user needs on top and a few other doctrine principles)
- The evolution theory
- The climatic patterns

Building a map has value, and the challenge of positioning the various components on the map itself brings a lot of value.

While ChatGPT is not aware of the spatial representation, it can provide rationales about the placement. 
However, as a human, a visual representation is very helpful.

Therefore, as a geek, I started thinking about a plugin that would enable ChatGPT to draw a map.

In a previous article, I introduced wardleyToGo, an SDK for building Wardley Maps using Go code. 
As a ChatGPT subscriber, I can write a plugin for GPT-4.

This article is a journey that explains how I built a plugin to draw my maps, how it works, what I discovered, and more.

You may want to read this article if:

- You are a curious Wardley Mapper.
- You are a ChatGPT user and want to be aware of the upcoming possibilities.
- You are a Go developer and want to be familiar with the plumbing required to create a plugin for ChatGPT."

## How a plugin works

The development of plugins for ChatGPT is documented [here](https://platform.openai.com/docs/plugins/introduction)
In a glimpse, a plugin is a REST API that is called by ChatGPT.

To turn an API into a plugin, you must provide two files:

- a [plugin manifest](https://platform.openai.com/docs/plugins/getting-started/plugin-manifest) file served at `/.well-known/ai-plugin.json`
- the openAPI spec served through a path specified in the `ai-plugin.json` file.

The format of the manifest is important because, besides the serialization in JSON, the format is constrained.
For example, the field `name_for_model` must not have any space and should be limited to 50 character max.	

![](/assets/gpt/gpt.png)

### Golang plumbing

In this section, I describe the plumbing I used in the Go file to create the plugin. This section is unrelated to the main feature and can
probably be used for any golang plugin.
_Disclaimer_ you may be familiar with the concepts of web handlers and how Go works to benefit from this section.

I am in the _make it work_  phase; therefore all the code lives in the `main` package of a file.
To be able to tweak the code easily, I created two seperate handlers:

- one for the plumbing (to serve the manifest, the spec, the root and the logo)
- one for the API itself

The plumbing is managed through the `ChatGPTPlumbing` structure that implements the [`http/handler`](https://pkg.go.dev/net/http#Handler)
This structure will read and generate the content of the manifest and the openapi upon creation and cache it internally.


```go
type ChatGPTPlumbing struct {
	aiPlugin        *AIPlugin
	aiPluginPayload []byte
	openAPIFile     string
	openAPIContent  []byte
}

// ChatGPTPlumbing implements the http/handler interface 
func (chatgptplumbing *ChatGPTPlumbing) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	mux := http.NewServeMux()
	mux.HandleFunc("/.well-known/ai-plugin.json", func(w http.ResponseWriter, _ *http.Request) { // ...
	mux.HandleFunc("/openapi.yaml", func(w http.ResponseWriter, _ *http.Request) { // ...
	mux.HandleFunc("/logo.png", func(w http.ResponseWriter, _ *http.Request) { // ...
	mux.ServeHTTP(w, r)
}
```

The plumbing is created inside the `main` function and registered to handle the requests located at `/`

```go
plumbing, _ := NewChatGPTPlumbing(aiPlugin)
mux := http.NewServeMux()
mux.Handle("/", plumbing)
```

The manifest and the openAPI are read (and validated) on the creation of the plugin and cached in the structure.

#### Create and validate the `aiplugin.json`

The manifest needs to be instanciated at runtime to set the correct listening port and address.
I created a Golang structure to handle the content and used the `json` package to serialize it.

On top of that, as I explained before, the aiplugin.json is heavily constrained. 
As I am in the _make it work_ phase, I will change the content very often for testing purpose.

The best thing for me is to validate the plugin constraints each time I start the plugin. 

To achieve this, I am relying on the CUE language.

I created a very simple constraint file, that I combine with a configuration file at startup to generate the content of the API:

- constraints.cue
```CUE
Host: string | *"AUTO"

#AIPlugin: {
	// SchemaVersion Manifest schema version - required - v1
	schema_version: string & "v1"

	// NameForHuman Human-readable name, such as the full company name. 20 character max. - required
	name_for_human: string & =~"^.{1,20}$"

	// NameForModel Name the model will use to target the plugin (no spaces allowed, only letters and numbers). 50 character max. - required
	name_for_model: string & =~"^[a-zA-Z0-9]{1,50}$"

	// DescriptionForHuman Human-readable description of the plugin. 100 character max.
	description_for_human: string & =~"^.{1,100}$"

	// DescriptionForModel Description better tailored to the model, such as token context length considerations or keyword usage for improved plugin prompting. 8,000 character max. - required
	description_for_model: string & =~"^.{20,1000}$"
	auth:                  #Auth
	api:                   #API
	logo_url:              string | *"\(Host)/logo.png"
	contact_email:         string & =~"^.*@.*$"
	legal_info_url:        string | *"\(Host)/legal"
}

#Auth: {
	type: string | *"none"
}

#API: {
	type:                  string | *"openapi"
	url:                   string | *"\(Host)/openapi.yaml"
	is_user_authenticated: bool | *false
}
```
- configuration.cue
```cue
configuration: #AIPlugin & {
	name_for_human:        "Wardley To Go"
	name_for_model:        "WardleyToGo"
	description_for_human: "This plugin draw Wardley Maps"
	description_for_model: "This plugin draw Wardley Maps"
	contact_email:         "me@address.com"
}
```

The `Host` is completed at runtime, and everything is combined to generate the go structure that is then serialized:

```go
host := `Host: "` + address + `"`
constraints, err := ioutil.ReadFile("constraints.cue")
configuration, err := ioutil.ReadFile("wellknown.cue")
content := append(constraints, configuration...)
content = append([]byte(host+"\n"), content...)
ctx := cuecontext.New()
v := ctx.CompileBytes(content)
v = v.Lookup("configuration")
var aiplugin AIPlugin
err = v.Decode(&aiplugin)
```


#### Create and serve the OpenAPI

- **The easy way**

- **The Geeky way**

#### Network plumbing
- serving from localhost
- tunneling with ngrok 

## Designing the API

### Creating a basic endpoint to display evolution axis

### Testing the plugin

### Displaying the SVG, tips and tricks


## Conclusion