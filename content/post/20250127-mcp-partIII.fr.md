---
title: "MCP Partie III - Application : Serveur personnalis√© pour un cas d‚Äôusage sp√©cifique"
date: 2025-01-27T12:15:33+01:00
lastmod: 2025-01-27T12:15:33+01:00
images: [/assets/mcp/diagram.png]
draft: false
keywords: []
summary: Cet ultime article d'une s√©rie en trois parties explore la s√©paration des outils de l‚Äôh√¥te gr√¢ce au Model Context Protocol (MCP), offrant flexibilit√© et r√©utilisabilit√©. L‚Äôauteur d√©veloppe un outil bas√© sur MCP en Go pour ex√©cuter des requ√™tes SQL via DuckDB, permettant une interaction fluide avec un chatbot tout en pr√©servant la confidentialit√©. L‚Äôimpl√©mentation couvre la gestion des appels JSON-RPC, l‚Äôencapsulation des outils et leur int√©gration. Le projet valide l‚Äôefficacit√© de MCP, avec des perspectives d‚Äô√©volution incluant le remplacement de VertexAI par Ollama et l‚Äôajout de la gestion multi-session.
tags: []
categories: []
author: "Olivier Wulveryck"
comment: false
toc: true
autoCollapseToc: false
# You can also define another contentCopyright.
contentCopyright: false
reward: false
mathjax: false
---

Dans les deux premi√®res parties (voir [partie I](/fr/2025/01/27/mcp-partie-i-concepts-fondamentaux-pass√©-pr√©sent-et-futur-des-syst√®mes-agents.html) et [partie II](/fr/2025/01/27/mcp-partie-ii-impl√©mentation-h√¥te-personnalis√©-avec-vertexai-et-gemini.html)) de cette s√©rie, nous avons :

- d√©crit le syst√®me agentique et comment il pouvait √™tre √©tendu gr√¢ce √† l‚Äôutilisation d‚Äôoutils ;
- expliqu√© en quoi un standard comme MCP √©tait essentiel pour construire un √©cosyst√®me vertueux ;
- construit un h√¥te ¬´ from scratch ¬ª : nous avons impl√©ment√© un chatbot priv√© et lui avons donn√© la capacit√© d‚Äôex√©cuter un outil.

Dans cette derni√®re partie, nous allons tenir la promesse initiale : nous allons cr√©er un outil d√©coupl√© de l‚Äôh√¥te.

En d√©couplant l‚Äôoutil de l‚Äôh√¥te, nous garantissons flexibilit√©, interop√©rabilit√© et r√©utilisabilit√© entre diff√©rents agents d‚ÄôIA. Cela s‚Äôaligne avec l‚Äôobjectif plus large de cr√©ation d‚Äôun syst√®me modulaire et √©volutif.

Voici le sch√©ma cible de ce que nous d√©crivons dans l‚Äôarticle :

![L‚Äôimage est un organigramme illustrant le Model Context Protocol (MCP) avec des blocs interconnect√©s et des fl√®ches directionnelles. Le texte et les fl√®ches en bleu repr√©sentent un ensemble de composants et de processus, tandis que ceux en rouge en repr√©sentent un autre. En haut √† gauche, un bloc avec du texte bleu est √©tiquet√© ¬´ Role ¬ª, qui est connect√© √† un bloc √©tiquet√© en rouge avec le texte ¬´ Model ¬ª. Ce bloc rouge a des fl√®ches qui s‚Äô√©tendent vers la droite, menant √† d‚Äôautres composants √©tiquet√©s en bleu et en rouge. Sous le bloc ¬´ Role ¬ª, d‚Äôautres blocs √©tiquet√©s en bleu sont connect√©s verticalement, indiquant des relations hi√©rarchiques ou s√©quentielles. Des fl√®ches rouges s‚Äôentrelacent avec les composants bleus, sugg√©rant des interactions crois√©es ou des d√©pendances entre les deux flux. Le diagramme repr√©sente visuellement les relations structurelles et les interactions au sein du cadre MCP, mettant en avant l‚Äôinteraction entre les √©l√©ments bleus et rouges.](/assets/mcp/partI/Image5.png)

## Exposition d‚Äôun cas d‚Äôusage

J‚Äôai appris SQL au si√®cle dernier et l‚Äôai √† peine utilis√© depuis. Ainsi, chaque fois que je dois explorer un jeu de donn√©es simple, j‚Äôutilise du code (un langage de programmation ou une combinaison de `grep`, `awk`, `sed` et leurs amis).

Cependant, dans la phase d‚Äôexploration, SQL pr√©sente des avantages, et un outil comme DuckDB peut √™tre d‚Äôune grande aide.

Actuellement, j‚Äôutilise un chatbot pour g√©n√©rer des requ√™tes SQL que je copie-colle dans l‚Äôinterface de DuckDB, mais ce n‚Äôest pas optimal.  
Mon cas d‚Äôusage consiste donc √† cr√©er un outil qui sera un serveur MCP, exposant une seule fonction :

- ex√©cuter une requ√™te via DuckDB (l‚Äôargument √©tant la requ√™te).

Mon objectif est de pouvoir utiliser un chatbot pour faire quelque chose comme ceci :

> - üë§ Peux-tu me donner le sch√©ma des donn√©es contenues dans le fichier local en ex√©cutant une requ√™te SQL (DuckDB) :  
>  `/tmp/ValeursFoncieres-2024-S1.tsv`  
> - üß† Le fichier `/tmp/ValeursFoncieres-2024-S1.tsv` contient 43 colonnes. Voici les noms et types de donn√©es des premi√®res colonnes :
> 
> | Nom de colonne         | Type de donn√©es |
> |----------------------|----------------|
> | Identifiant de doc‚Ä¶  | varchar        |
> | R√©f√©rence document   | varchar        |
> | ...                  | ...            |
> | Nature culture       | varchar        |
> | Nature culture spe‚Ä¶  | varchar        |
> | Surface terrain      | int64          |
> 
> Je peux fournir plus de d√©tails si tu pr√©cises les colonnes qui t‚Äôint√©ressent.
> - üë§ Ok, ce fichier est en fran√ßais.  
> Mon code postal est 59700, quel est le co√ªt moyen des transactions dans cette ville ?
> 
> - üß† **Ah, il semble que je doive caster la colonne "Valeur fonci√®re" en un type num√©rique avant de calculer la moyenne. Je vais essayer un CAST en DOUBLE.**  
> 
> **Le probl√®me vient du format de la colonne "Valeur fonci√®re". La virgule est utilis√©e comme s√©parateur d√©cimal, ce qui n‚Äôest pas compatible avec la fonction CAST. Je vais remplacer la virgule par un point avant de caster en DOUBLE.**  
> 
> Le co√ªt moyen des transactions dans la ville avec le code postal 59700 est de **441 545,00**.
> 
> - üë§ Quelle est la surface moyenne des terrains dans cette ville ?
> - üß† La surface moyenne des terrains dans la ville avec le code postal 59700 est de **444,60 m√®tres carr√©s**.
> - üë§ Quel est le prix moyen au m√®tre carr√© ?
> - üß† Le prix moyen au m√®tre carr√© dans la ville avec le code postal 59700 est de **3 532,92 ‚Ç¨**.
> - üë§ Compare avec la ville dont le code postal est 59000.
> - üß† Le prix moyen au m√®tre carr√© dans la ville avec le code postal 59000 est de **3 978,29 ‚Ç¨**.  
> Compar√© √† la ville avec le code postal 59700, o√π le prix moyen au m√®tre carr√© est de **3 532,92 ‚Ç¨**, la ville avec le code postal 59000 a un prix moyen plus √©lev√©.
> - üë§ Et par rapport √† la ville dont le code postal est 62100 ?
> - üß† Le prix moyen au m√®tre carr√© dans la ville avec le code postal 62100 est de **1 810,66 ‚Ç¨**.  
> Compar√© √† la ville avec le code postal 59700 (**3 532,92 ‚Ç¨/m¬≤**) et la ville avec le code postal 59000 (**3 978,29 ‚Ç¨/m¬≤**), la ville avec le code postal 62100 a un prix moyen au m√®tre carr√© nettement inf√©rieur.
> - üë§ Fais-moi un r√©sum√© de tout √ßa dans un tableau en fran√ßais.
> - üß† 
> 
> | Code Postal | Prix moyen au m¬≤ |
> |------------|------------------|
> | 59700      | 3 532,92 ‚Ç¨       |
> | 59000      | 3 978,29 ‚Ç¨       |
> | 62100      | 1 810,66 ‚Ç¨       |
> 
> En r√©sum√©, le prix moyen au m√®tre carr√© varie consid√©rablement entre ces trois villes. La ville avec le code postal **59000** a le prix moyen au m√®tre carr√© le plus √©lev√©, suivie par la ville avec le code postal **59700**. La ville avec le code postal **62100** a un prix moyen nettement inf√©rieur aux deux autres.



## L'outil

L'outil que nous d√©veloppons est simple : un wrapper autour de DuckDB exposant une seule fonction `query`.  
Je ne vais pas entrer dans les d√©tails de l‚Äôimpl√©mentation, mais en gros, c‚Äôest juste une ex√©cution autour de `duckdb`.  
J‚Äôai choisi de ne pas utiliser une biblioth√®que embarqu√©e pour garder les choses simples.

```go
func executeDuckDBQuery(queryStr string) (string, error) { ... }
```

### Encapsulation avec le protocole MCP

### Comprendre les appels JSON-RPC et le handshake

Le protocole MCP est bas√© sur JSON-RPC. L‚Äôh√¥te appellera l‚Äôoutil via un appel RPC qui ressemblera √† ceci :

```json
{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{"name":"function_name","arguments":{"query":"LA REQU√äTE SQL"}}}
```

### Gestion des requ√™tes en Go

Nous devons donc √©crire une fonction capable de comprendre cette structure et d‚Äôappeler correctement `executeDuckDBQuery`.  
Plut√¥t que d‚Äôanalyser manuellement les requ√™tes JSON-RPC, nous utilisons la biblioth√®que `github/mark3labs/mcp-go`, qui simplifie la gestion des requ√™tes et assure la compatibilit√© avec le protocole MCP.

La requ√™te JSON-RPC est encapsul√©e dans un objet `mcp.CallToolRequest`, et le r√©sultat attendu est un `mcp.CallToolResult`. Il suffit d‚Äôextraire la requ√™te et d‚Äôappeler notre fonction comme ceci :

```go
// Extrait la requ√™te SQL de la requ√™te et l‚Äôex√©cute via DuckDB
func duckDBHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	queryStr, ok := request.Params.Arguments["query"].(string)
	if !ok {
		return mcp.NewToolResultError("query doit √™tre une cha√Æne de caract√®res"), nil
	}
	res, err := executeDuckDBQuery(queryStr)
	if err != nil {
		return mcp.NewToolResultError("Une erreur est survenue lors de l‚Äôex√©cution de la requ√™te : " + err.Error()), nil
	}
	return mcp.NewToolResultText(res), nil
}
```

### Exposer l'outil au LLM h√¥te

La fonction doit √™tre expos√©e en tant qu‚Äôoutil pour √™tre utilisable par le LLM h√¥te.  
Le serveur d√©clarera ses outils lorsque l‚Äôh√¥te enverra cette requ√™te :

```json
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"example-client","version":"1.0.0"},"capabilities":{}}}
{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}
```

Le serveur peut r√©pondre avec quelque chose comme :

```json
{"jsonrpc":"2.0","id":2,"result":{"tools":[{"name":"FUNCTION_NAME","description":"DESCRIPTION DE LA FONCTION","inputSchema":{"type":"object","properties":{"query":{"description":"DESCRIPTION DU PARAM√àTRE QUERY","type":"string"},"required":["query"]}}]}}
```

√Ä noter que les descriptions fournies sont tr√®s importantes, car elles seront utilis√©es par le LLM pour choisir la bonne fonction et formater les param√®tres correctement.

La biblioth√®que `go-mcp` fournit des utilitaires pour faire cela :

```go
// Ajouter un outil
tool := mcp.NewTool("query_file",
  mcp.WithDescription("Ex√©cute une requ√™te SQL via DuckDB pour extraire les informations d‚Äôun fichier. Le fichier peut √™tre local (contenant '/'), ou distant sur Hugging Face (commen√ßant par 'hf:'). Il peut aussi contenir des caract√®res g√©n√©riques ('*')."),
  mcp.WithString("query",
    mcp.Required(),
    mcp.Description("La requ√™te SQL √† ex√©cuter (compatible avec DUCKDB)"),
  ),
)
```

## Exposer l'outil

Jusqu'√† pr√©sent, nous avons encapsul√© tous les outils dans des appels JSON-RPC.  
Nous avons maintenant besoin d'une couche de transport.

MCP propose deux options :

- Exposer et communiquer via le r√©seau en utilisant les Server-Sent Events (SSE).
- Exposer l'outil via un fork local et communiquer via STDIO.

Nous allons utiliser cette derni√®re option.

_Remarque :_ Bien qu'il soit possible d'utiliser n'importe quel langage pour l'outil, Go est un excellent choix. Ses binaires statiques auto-contenus facilitent la distribution sans se soucier des d√©pendances externes.

Encore une fois, la biblioth√®que `go-mcp` s'occupe du code r√©p√©titif pour enregistrer l'outil avec son gestionnaire associ√© :

```go
// Cr√©er un serveur MCP
s := server.NewMCPServer(
	"DuckDB üöÄ",
	"1.0.0",
)
// Ajouter un gestionnaire d'outil
s.AddTool(tool, duckDBHandler)
```

## Compilation et ex√©cution de l'outil

Une fois compil√©, nous pouvons essayer d'ex√©cuter l'outil localement.

```bash
‚ùØ go build -o duckdbserver
‚ùØ # Obtenir les capacit√©s du serveur 
‚ùØ echo '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' | ./duckdbserver
{"jsonrpc":"2.0","id":2,"result":{"tools":[{"name":"query_file","description":"Ex√©cute une requ√™te SQL via DuckDB pour extraire les informations d‚Äôun fichier. Le fichier peut √™tre local (contenant '/'), ou distant sur Hugging Face (commen√ßant par 'hf:'). Il peut aussi contenir des caract√®res g√©n√©riques ('*').","inputSchema":{"type":"object","properties":{"query":{"description":"La requ√™te SQL √† ex√©cuter (compatible avec DUCKDB)","type":"string"}},"required":["query"]}}]}}
‚ùØ # Ex√©cuter une requ√™te
‚ùØ echo '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"query_file","arguments":{"query":"SELECT version() AS version;"}}}' | ./duckdbserver
{"jsonrpc":"2.0","id":3,"result":{"content":[{"type":"text","text":"‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ version ‚îÇ\n‚îÇ varchar ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ v1.1.3  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"}]}}
```

Tout fonctionne bien jusqu‚Äôici... Vous remarquez que je n‚Äôai sp√©cifi√© aucun format de sortie, laissant le LLM d√©cider de son utilisation.

## Conclusion

Le travail restant consiste √† int√©grer tous les composants. J‚Äôai cr√©√© une structure g√©n√©rique `MCPServerTool` c√¥t√© h√¥te, qui enregistre un outil configurable via la variable d‚Äôenvironnement `MCP_SERVER`.

Voici le sch√©ma final du code :  
![](/assets/mcp/diagram.png)

Le r√©sultat, comme vous pouvez l‚Äôimaginer, est que le dialogue initial est maintenant une v√©ritable conversation que je m√®ne avec l‚Äôagent.

Ainsi, ajouter un outil √† un LLM tout en gardant mes informations priv√©es devient simple. En effet, lorsqu‚Äôun serveur MCP fournit des ressources, le LLM y acc√®de.

Les prochaines √©tapes incluent le remplacement de VertexAI par, par exemple, Ollama et la gestion des √©l√©ments multi-sessions.

Avec ces derni√®res remarques, je peux affirmer que j‚Äôai atteint mon objectif et valid√© les concepts cl√©s.

Si vous souhaitez essayer ce serveur, le code est disponible sur [mon GitHub](https://github.com/owulveryck/gomcptest).

