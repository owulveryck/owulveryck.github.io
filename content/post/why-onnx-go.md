---
title: "Why Onnx Go"
date: 2019-03-02T21:03:33+01:00
lastmod: 2019-03-02T21:03:33+01:00
draft: true
keywords: []
description: "In this short post, I explain why I trust in Go and ONNX and why I think they together they form a viable choice for running machine learning at scale."
tags: []
categories: []
author: ""

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: true
toc: false
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: "This is another copyright."
contentCopyright: false
reward: false
mathjax: false
---

<!--more-->

_Machine learning is a growing concern for IT specialist (Dev and Ops). Indeed, many companies evaluate the opportunity of executing a machine learning algorithm in any of their product._

> If data is the new oil, ML is the new soil! 
> Let the soil be fertile and easy to work on.

_In this short post, I explain why I trust in Go and ONNX and why I think that together they form a viable choice for running machine learning at scale._

---

# Go: a painless engine for automatons
People have always been fascinated by artificial intelligence. 
Programming an automaton for eliminating toil or coding a robot to assist the choices is a long dream of every "lazy" geek. Actually, automation is a simple form of artificial intelligence. Scripting tedious tasks is a smart way to be lazy. However, maintaining the scripts can also be tedious and time-consuming.

A study showed that 90% of the costs of software were related to its maintenance. Therefore, the total cost of ownership of modern software is correlated mainly to three factors:

* its reliability;
* the cost for extending it (adding a new feature for example);
* its ability to efficiently run at scale.

<center>
![Mandatory XKCD](https://imgs.xkcd.com/comics/automation.png)
</center>

The way the Go authors have addressed those concerns is interesting.

Go is a language that is simple to learn and to use even on complex use-cases (the SDK is battery-included; no need for a third-party framework).
On top of that, the language is highliy opinionated in a way that allows developers to focus on what they do instead of how to do it.

But most of all: a Go program do not increase the toil when running at scale.
Its self-contained static binary is one of the most DevOps friendly principles so far. It's probably one of the reasons why it is so widely present in the hosting and Ops ecosystem.

How is this related to machine learning? 

Nowadays, 


To act without being explicitly instructed.

We can write software. 


The rise and fall of Tensorflow




To apply the concepts of Go to software 2.0? 


When a software plays the model

Nobody's a nobody


