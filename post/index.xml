<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Unladen swallow - Olivier Wulveryck</title><link>https://owulveryck.github.io/post/</link><description>Recent content in Posts on Unladen swallow - Olivier Wulveryck</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Olivier Wulveryck</copyright><lastBuildDate>Sun, 26 Apr 2020 15:47:57 +0200</lastBuildDate><atom:link href="https://owulveryck.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Divide et impera - part I: coupling</title><link>https://owulveryck.github.io/2020/04/26/divide-et-impera-part-i-coupling/</link><pubDate>Sun, 26 Apr 2020 15:47:57 +0200</pubDate><guid>https://owulveryck.github.io/2020/04/26/divide-et-impera-part-i-coupling/</guid><description>In 2020, an old debate has risen from the ashes:
Monolith or micro-services?
In the past years, I have been working on IT products designed to work at scale. The micro-services pattern suits this need and is, therefore, the paradigm chosen de facto.
An application composed of micro-services is supposed to be scalable; the main pitfall is to think and design accurate service contracts to avoid the antipattern of a distributed monolith.</description></item><item><title>Think like a vertex: using Go&#39;s concurrency for graph computation</title><link>https://owulveryck.github.io/2019/10/14/think-like-a-vertex-using-gos-concurrency-for-graph-computation/</link><pubDate>Mon, 14 Oct 2019 22:26:42 +0200</pubDate><guid>https://owulveryck.github.io/2019/10/14/think-like-a-vertex-using-gos-concurrency-for-graph-computation/</guid><description/></item><item><title>A simple face detection utility from Python to Go</title><link>https://owulveryck.github.io/2019/08/16/a-simple-face-detection-utility-from-python-to-go/</link><pubDate>Fri, 16 Aug 2019 21:25:30 +0200</pubDate><guid>https://owulveryck.github.io/2019/08/16/a-simple-face-detection-utility-from-python-to-go/</guid><description>In this article, I explain how to build a tool to detect faces in a picture. This article is a sort of how-to design and implements a tool by using a neural network.
For the design part, I describe how to:
build the business model thanks to a neural network; adapt the network to the specific domain of face detection by changing its knowledge; use the resulting domain with a go-based infrastructure; code a little application in Go to communicate with the outside world.</description></item><item><title>From a project to a product: the state of onnx-go</title><link>https://owulveryck.github.io/2019/04/03/from-a-project-to-a-product-the-state-of-onnx-go/</link><pubDate>Wed, 03 Apr 2019 20:33:42 +0200</pubDate><guid>https://owulveryck.github.io/2019/04/03/from-a-project-to-a-product-the-state-of-onnx-go/</guid><description>&lt;script src=&#34;https://owulveryck.github.io/js/fabric.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://owulveryck.github.io/js/wasm_exec1.12.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://owulveryck.github.io/js/loader_onnx.js&#34;&gt;&lt;/script&gt;</description></item><item><title>My journey with ONNX and Go - Running the graph</title><link>https://owulveryck.github.io/2018/09/19/my-journey-with-onnx-and-go-running-the-graph/</link><pubDate>Wed, 19 Sep 2018 08:53:09 +0200</pubDate><guid>https://owulveryck.github.io/2018/09/19/my-journey-with-onnx-and-go-running-the-graph/</guid><description>In the previous post, I made an introduction and a POC to interact with ONNX models and Go.
I have decoded the information to reconstruct a graph. Now I propose to expand the principle and to create a proper execution backend based on Gorgonia. This post is a bit more technical than the previous one because all the concepts needed to work should be present in the last article.</description></item><item><title>My journey with ONNX and Go - The beginning</title><link>https://owulveryck.github.io/2018/08/14/my-journey-with-onnx-and-go-the-beginning/</link><pubDate>Tue, 14 Aug 2018 20:41:30 +0200</pubDate><guid>https://owulveryck.github.io/2018/08/14/my-journey-with-onnx-and-go-the-beginning/</guid><description>This year has started with a lot of deep thoughts about the software 2.0. My conclusion (which is slightly different from Andrej Karpathy&amp;rsquo;s consideration) is that a software 2.0 is a combination of a Neural network model and its associated weights. This is a concept; now the question is: how to materialize the idea? What artifact represents a software 2.0.
I emitted several ideas and tried one of them: to serialize the mathematical model and the weights.</description></item><item><title>Recurrent Neural Network, Serverless with Webassembly and S3</title><link>https://owulveryck.github.io/2018/06/11/recurrent-neural-network-serverless-with-webassembly-and-s3/</link><pubDate>Mon, 11 Jun 2018 10:54:59 +0200</pubDate><guid>https://owulveryck.github.io/2018/06/11/recurrent-neural-network-serverless-with-webassembly-and-s3/</guid><description>During the past weeks, I&amp;rsquo;ve had the opportunity to play a bit with Wasm and Go.
All those experiments led me to a write a proof of concepts that can illustrate everything I have said recently about:
Thinking the deep-learning stack like an Ops (see my post about NNRE/NNDK). Capturing the real value of the training process (the knowledge) into a sequence of bits (the lightning talk I gave about it at the dotAI should be online soon).</description></item><item><title>Some notes about the upcoming WebAssembly support in Go</title><link>https://owulveryck.github.io/2018/06/08/some-notes-about-the-upcoming-webassembly-support-in-go/</link><pubDate>Fri, 08 Jun 2018 21:23:17 +0200</pubDate><guid>https://owulveryck.github.io/2018/06/08/some-notes-about-the-upcoming-webassembly-support-in-go/</guid><description/></item><item><title>Considerations about software 2.0</title><link>https://owulveryck.github.io/2018/04/16/considerations-about-software-2.0/</link><pubDate>Mon, 16 Apr 2018 10:54:23 +0200</pubDate><guid>https://owulveryck.github.io/2018/04/16/considerations-about-software-2.0/</guid><description>Disclaimer This is a technical article about a work in progress. The primary goal is to document what I did and to clarify my ideas. A more general and complete article about software 2.0 is in development and should be published on my company&amp;rsquo;s blog later.
This post describes the concept of software 2.0. It evaluates an instance of the Unicode equation parser (as described here) to give a strict separation of the software 1.</description></item><item><title>Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go</title><link>https://owulveryck.github.io/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs-first-step-from-software-1.0-to-2.0-in-go/</link><pubDate>Mon, 18 Dec 2017 16:47:27 +0100</pubDate><guid>https://owulveryck.github.io/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs-first-step-from-software-1.0-to-2.0-in-go/</guid><description>In a previous article, I described an implementation of an RNN from scratch in go. The target is to use the RNN as a processing unit. The ultimate goal is to create a portable tool cross platform and able to grab and process data where they are. I have many applications in mind such as finding the root-cause of an incident or managing the capacity of an infrastructure.
Note I stick to the Go language for many reasons: Some of them a personnal and not opposable (I simply like it).</description></item><item><title>About Recurrent Neural Network, Shakespeare and GO</title><link>https://owulveryck.github.io/2017/10/29/about-recurrent-neural-network-shakespeare-and-go/</link><pubDate>Sun, 29 Oct 2017 07:17:33 +0100</pubDate><guid>https://owulveryck.github.io/2017/10/29/about-recurrent-neural-network-shakespeare-and-go/</guid><description>Shakespeare and I, encounter of the third type A couple of months ago, I attended the Google Cloud Next 17 event in London. Among the talks about SRE, and keynotes, I had the chance to listen to Martin Gorner&amp;rsquo;s excellent introduction: TensorFlow and Deep Learning without a PhD, Part 2. If you don&amp;rsquo;t want to look at the video, here is a quick summary:
a 100 of lines of python are reading all Shakespeare&amp;rsquo;s plays; it learns his style, and then generates a brand new play from scratch.</description></item><item><title>Terraform is hip... Introducing Nhite</title><link>https://owulveryck.github.io/2017/09/12/terraform-is-hip...-introducing-nhite/</link><pubDate>Tue, 12 Sep 2017 13:28:36 +0200</pubDate><guid>https://owulveryck.github.io/2017/09/12/terraform-is-hip...-introducing-nhite/</guid><description>In a previous post, I did some experiments with gRPC, protocol buffer and Terraform. The idea was to transform the &amp;ldquo;Terraform&amp;rdquo; cli tool into a micro-service thanks to gRPC.
This post is the second part of the experiment. I will go deeper in the code and see if it is possible to create a brand new utility, without hacking Terraform. The idea is to import some packages that compose the binary and create my own service based on gRPC.</description></item><item><title>From command line tools to microservices - The example of Hashicorp tools (terraform) and gRPC</title><link>https://owulveryck.github.io/2017/09/02/from-command-line-tools-to-microservices-the-example-of-hashicorp-tools-terraform-and-grpc/</link><pubDate>Sat, 02 Sep 2017 13:28:36 +0200</pubDate><guid>https://owulveryck.github.io/2017/09/02/from-command-line-tools-to-microservices-the-example-of-hashicorp-tools-terraform-and-grpc/</guid><description>This post is a little different from the last ones. As usual, the introduction tries to be open, but it quickly goes deeper into a go implementation. Some explanations may be tricky from time to times and therefore not very clear. As usual, do not hesitate to send me any comment via this blog or via twitter @owulveryck.
TL;DR: This is a step-by-step example that turns a golang cli utility into a webservice powered by gRPC and protobuf.</description></item><item><title>A &#34;Smart&#34; CCTV with Tensorflow, and Inception? On a rapsberry pi?</title><link>https://owulveryck.github.io/2017/07/07/a-smart-cctv-with-tensorflow-and-inception-on-a-rapsberry-pi/</link><pubDate>Fri, 07 Jul 2017 21:06:46 +0200</pubDate><guid>https://owulveryck.github.io/2017/07/07/a-smart-cctv-with-tensorflow-and-inception-on-a-rapsberry-pi/</guid><description>Imagine a CCTV at home that would trigger an alert when it detects a movement.
Ok, this is easy.
Imagine a CCTV that would trigger an alert when it detects a human (and not the cat).
A little bit trickier.
Now imagine a CCTV that would trigger an alert when it sees someone who is not from the family&amp;hellip;
Disclaimer: This article will not cover everything. I may post a second article later (or not).</description></item><item><title>Analyzing a parodic trailer (NSFW) with Google Cloud Video Intelligence</title><link>https://owulveryck.github.io/2017/06/01/analyzing-a-parodic-trailer-nsfw-with-google-cloud-video-intelligence/</link><pubDate>Thu, 01 Jun 2017 22:07:56 +0200</pubDate><guid>https://owulveryck.github.io/2017/06/01/analyzing-a-parodic-trailer-nsfw-with-google-cloud-video-intelligence/</guid><description>Google has recently announced its new service called &amp;ldquo;Google Cloud Video Intelligence&amp;rdquo;. The purpose of this service is to offer tagging and annotations of digital videos.
I will try this service on a trailer of a French parody. This movie is made of several scenes taken from erotic movies of the seventies.
Why this parody?
because it is fun because it is composed of a lot of different scenes because it is short (so it won&amp;rsquo;t cost me a lot) because, as it is related to erotic of the seventies, I am curious about the result!</description></item><item><title>Chrome, the eye of the cloud - Computer vision with deep learning and only 2Gb of RAM</title><link>https://owulveryck.github.io/2017/05/16/chrome-the-eye-of-the-cloud-computer-vision-with-deep-learning-and-only-2gb-of-ram/</link><pubDate>Tue, 16 May 2017 21:43:46 +0200</pubDate><guid>https://owulveryck.github.io/2017/05/16/chrome-the-eye-of-the-cloud-computer-vision-with-deep-learning-and-only-2gb-of-ram/</guid><description>TL;DR: Thank you for passing by. This article is, as usual, geek oriented. However, if you are not a geek, and/or you are in a hurry, you can jump to the conclusion: Any real application?
During the month of may, I have had the chance to attend to the Google Next event in London and the dotAI in Paris. In both conferences I learned a lot about machine learning.</description></item><item><title>I have tried Extreme Programming within a sprint and I think it is an excellent agile method for the Ops!</title><link>https://owulveryck.github.io/2017/04/14/i-have-tried-extreme-programming-within-a-sprint-and-i-think-it-is-an-excellent-agile-method-for-the-ops/</link><pubDate>Fri, 14 Apr 2017 23:00:59 +0200</pubDate><guid>https://owulveryck.github.io/2017/04/14/i-have-tried-extreme-programming-within-a-sprint-and-i-think-it-is-an-excellent-agile-method-for-the-ops/</guid><description>Part I: Agility 2003 I have discovered the notion of extreme programming more than 15 years ago. My job was to integrate and to develop pieces of code in Java for the IBM Websphere Business Integration server. We were a small team with light programming skills. A part of our job was to operate the software, the other part was to develop. It was in 2003.
We were trying hard to stick to the specific framework we developed.</description></item><item><title>From GraphQL to a table view with React and Apollo</title><link>https://owulveryck.github.io/2017/03/28/from-graphql-to-a-table-view-with-react-and-apollo/</link><pubDate>Tue, 28 Mar 2017 21:03:52 +0200</pubDate><guid>https://owulveryck.github.io/2017/03/28/from-graphql-to-a-table-view-with-react-and-apollo/</guid><description>In the last post I have played with GraphQL. The next step is to actually query the data and display it.
In this post I will use react (from Facebook) and the Apollo GraphQL client.
Tooling React I won&amp;rsquo;t give in here an introduction of the language because you may find on the web thousands of very good tutorials and advocacy articles. Anyway I will explain briefly why I have chosen React.</description></item><item><title>Playing with Facebook&#39;s GraphQL (applied to AWS products and offers management)</title><link>https://owulveryck.github.io/2017/03/22/playing-with-facebooks-graphql-applied-to-aws-products-and-offers-management/</link><pubDate>Wed, 22 Mar 2017 09:15:35 +0100</pubDate><guid>https://owulveryck.github.io/2017/03/22/playing-with-facebooks-graphql-applied-to-aws-products-and-offers-management/</guid><description>About GraphQL GraphQL has been invented by Facebook for the purpose of refactoring their mobile application. Facebook had reached the limits of the standard REST API mainly because:
Getting that much information was requiring a huge amount of API endpoints The versioning of the API was counter-productive regarding Facebook&amp;rsquo;s frequents deployements. But graphql is not only a query language related to Facebook. GraphQL is not only applicable to social data.</description></item><item><title>Linda&#39;s evalc, a (tuple)space oddity</title><link>https://owulveryck.github.io/2017/03/13/lindas-evalc-a-tuplespace-oddity/</link><pubDate>Mon, 13 Mar 2017 20:54:27 +0100</pubDate><guid>https://owulveryck.github.io/2017/03/13/lindas-evalc-a-tuplespace-oddity/</guid><description>For a change, I will start with a good soundtrack
(youtube version for those who are spotify-less)
This is my third article about the distributed coordination language Linda.
The final target of the work is to use this coordination mechanism to deploy and maintain applications based on the description of their topology (using, for example, TOSCA as a DSL).
Last time, I introduced a lisp based language (zygomys) as an embedded programing mechanism to describe the business logic.</description></item></channel></rss>